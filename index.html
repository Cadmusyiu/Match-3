<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Puzzle RPG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background-color: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        
        /* Main container - fixed width and height for consistent display */
        #game-container {
            width: 375px;
            height: 667px;
            background-color: #222;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            margin: 0 auto; /* Center horizontally */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        #dungeon-view {
            height: 120px;
            background-color: #333;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .enemy {
            width: 60px;
            height: 60px;
            background-color: #e57373;
            border-radius: 10px;
            position: relative;
        }
        
        .enemy::before {
            content: "";
            position: absolute;
            top: 15px;
            left: 10px;
            width: 10px;
            height: 10px;
            background-color: white;
            border-radius: 50%;
            box-shadow: 30px 0 0 white;
        }
        
        .enemy::after {
            content: "";
            position: absolute;
            top: 35px;
            left: 20px;
            width: 20px;
            height: 5px;
            background-color: #333;
        }
        
        #heroes-area {
            display: flex;
            justify-content: space-around;
            padding: 5px;
            background-color: #333;
            height: 65px;
        }
        
        .hero-card {
            width: 50px;
            height: 55px;
            background-color: #555;
            border-radius: 5px;
            border: 2px solid #777;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .hero-icon {
            height: 35px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
        }
        
        .hero-stats {
            height: 20px;
            background-color: #444;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            color: white;
        }
        
        #status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background-color: #222;
            border-top: 2px solid #444;
            border-bottom: 2px solid #444;
            height: 30px;
        }
        
        #health-bar {
            height: 16px;
            background-color: #444;
            border-radius: 8px;
            overflow: hidden;
            flex-grow: 1;
            margin: 0 10px;
        }
        
        #health-fill {
            height: 100%;
            background-color: #f25;
            width: 100%;
        }
        
        /* Critical fix: Changed grid to 6x5 instead of 6x6 */
        #grid-container {
            flex-grow: 1;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 2px;
            padding: 2px;
            background-color: #111;
            position: relative;
            width: 100%;
            height: calc(100% - 215px); /* Subtract header areas */
        }
        
        .gem {
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            transition: transform 0.2s, background-color 0.2s;
            width: 100%;
            height: 100%;
        }
        
        .gem.active {
            transform: scale(1.1);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
            z-index: 10;
        }
        
        .gem.matched {
            animation: pulse 0.5s infinite alternate;
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0.7; transform: scale(1.1); }
        }
        
        /* Path visuals */
        .path-line {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            z-index: 5;
        }
        
        .path-dot {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 6;
        }
        
        /* Timer display */
        #timer-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            z-index: 20;
            display: none;
        }
        
        #timer-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(#ffb703 0%, transparent 0%);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px black;
            animation: timer-pulse 1s infinite alternate;
        }
        
        @keyframes timer-pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }
        
        /* Combo text styles */
        #combo-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px #f00, 0 0 20px #ff0;
            opacity: 0;
            z-index: 30;
            pointer-events: none;
        }
        
        @keyframes combo-popup {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        
        /* Sparkle animation for matched gems */
        @keyframes sparkle {
            0% { transform: scale(1); opacity: 0.5; }
            100% { transform: scale(1.5); opacity: 1; }
        }
        
        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: white;
            box-shadow: 0 0 3px white, 0 0 5px white;
            pointer-events: none;
        }
        
        .water { background-color: #42a5f5; }
        .fire { background-color: #ff7043; }
        .heart { background-color: #ec407a; }
        .leaf { background-color: #66bb6a; }
        .star { background-color: #ffca28; }
        .moon { background-color: #9575cd; }
        
        /* Start overlay with game title and start button */
        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .start-title {
            font-size: 36px;
            margin-bottom: 30px;
            color: white;
            text-align: center;
        }
        
        .start-button {
            padding: 15px 40px;
            font-size: 24px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        .start-button:hover {
            background-color: #3e8e41;
        }
        
        /* Flash animation */
        @keyframes flash {
            0% { opacity: 0.3; }
            50% { opacity: 0.1; }
            100% { opacity: 0; }
        }
        
        /* Falling animation */
        @keyframes fall {
            0% { transform: translateY(-100%); }
            70% { transform: translateY(10%); }
            85% { transform: translateY(-5%); }
            100% { transform: translateY(0); }
        }
        
        /* Disappear animation */
        @keyframes disappear {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }
        
        /* Appear animation */
        @keyframes appear {
            0% { transform: scale(0); opacity: 0; }
            70% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Media queries for different device sizes */
        @media (max-height: 700px) {
            #game-container {
                height: 100vh;
                width: auto;
                aspect-ratio: 9/16;
            }
        }
        
        @media (max-width: 500px) {
            #game-container {
                width: 100vw;
                height: 100vh;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Dungeon view with enemy -->
        <div id="dungeon-view">
            <div class="enemy"></div>
        </div>
        
        <!-- Hero cards area -->
        <div id="heroes-area">
            <div class="hero-card">
                <div class="hero-icon" style="background-color: #ab47bc;">‚öîÔ∏è</div>
                <div class="hero-stats">13 ‚öîÔ∏è</div>
            </div>
            <div class="hero-card">
                <div class="hero-icon" style="background-color: #42a5f5;">üîÆ</div>
                <div class="hero-stats">18 ‚öîÔ∏è</div>
            </div>
            <div class="hero-card">
                <div class="hero-icon" style="background-color: #66bb6a;">‚úì</div>
                <div class="hero-stats">10 ‚öîÔ∏è</div>
            </div>
        </div>
        
        <!-- Health bar -->
        <div id="status-bar">
            <span>HP:</span>
            <div id="health-bar">
                <div id="health-fill"></div>
            </div>
            <span>15695/15705</span>
        </div>
        
        <!-- Game grid -->
        <div id="grid-container"></div>
        
        <!-- Timer display -->
        <div id="timer-container">
            <div id="timer-circle">5</div>
        </div>
        
        <!-- Combo text -->
        <div id="combo-text">COMBO!</div>
        
        <!-- Start overlay -->
        <div id="start-overlay">
            <h1 class="start-title">Puzzle RPG</h1>
            <button class="start-button" id="start-game-btn">START GAME</button>
        </div>
    </div>

    <script>
        // Wait for page to fully load
        window.onload = function() {
            // Game constants - 6x5 grid
            const GRID_COLS = 6;
            const GRID_ROWS = 5;
            const PATH_MOVE_TIME = 5; // seconds
            
            // Set up audio context and sounds
            let audioContext;
            
            // Initialize Audio Context on user interaction (browser requirement)
            function initAudio() {
                if (!audioContext) {
                    try {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        audioContext = new AudioContext();
                    } catch (e) {
                        console.error("Web Audio API not supported:", e);
                    }
                } else if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }
            
            // Sound generation function - creates the actual audio
            function playSound(freq, duration, type, volume) {
                if (!audioContext) return;
                
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = type || 'sine';
                    oscillator.frequency.value = freq;
                    gainNode.gain.value = volume || 0.1;
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                    
                    setTimeout(() => {
                        oscillator.stop();
                    }, duration * 1000);
                } catch (e) {
                    console.error("Error playing sound:", e);
                }
            }
            
            // Define sound patterns
            const sounds = {
                select: () => {
                    if (!audioContext) return;
                    playSound(400, 0.1, 'sine', 0.1);
                },
                swap: () => {
                    if (!audioContext) return;
                    playSound(500, 0.1, 'sine', 0.1);
                },
                match: () => {
                    if (!audioContext) return;
                    playSound(600, 0.15, 'triangle', 0.15);
                    setTimeout(() => playSound(700, 0.15, 'triangle', 0.15), 100);
                },
                combo: () => {
                    if (!audioContext) return;
                    playSound(600, 0.1, 'triangle', 0.2);
                    setTimeout(() => playSound(800, 0.15, 'triangle', 0.2), 150);
                    setTimeout(() => playSound(1000, 0.2, 'triangle', 0.2), 300);
                },
                timer: () => {
                    if (!audioContext) return;
                    playSound(300, 0.05, 'sine', 0.1);
                },
                drop: () => {
                    if (!audioContext) return;
                    playSound(500, 0.05, 'sine', 0.1);
                    setTimeout(() => playSound(400, 0.05, 'sine', 0.1), 50);
                    setTimeout(() => playSound(300, 0.05, 'sine', 0.1), 100);
                }
            };
            
            // Game state
            let gameState = {
                grid: [],
                heroes: [
                    { name: 'Warrior', health: 100, attack: 13 },
                    { name: 'Mage', health: 80, attack: 18 },
                    { name: 'Healer', health: 70, attack: 10 }
                ],
                enemies: [
                    { name: 'Enemy', health: 100, maxHealth: 100, attack: 10 }
                ],
                health: 15695,
                maxHealth: 15705,
                score: 0,
                currentPath: [],
                pathMode: false,
                pathTimer: null,
                pathTimeLeft: PATH_MOVE_TIME,
                gemElements: []
            };
            
            // Get DOM elements
            const startOverlay = document.getElementById('start-overlay');
            const startButton = document.getElementById('start-game-btn');
            const gridContainer = document.getElementById('grid-container');
            const healthFill = document.getElementById('health-fill');
            const timerContainer = document.getElementById('timer-container');
            const timerCircle = document.getElementById('timer-circle');
            const comboText = document.getElementById('combo-text');
            
            // Gem types
            const GEM_TYPES = [
                { id: 'water', symbol: 'üíß', color: '#42a5f5' },
                { id: 'fire', symbol: 'üî•', color: '#ff7043' },
                { id: 'heart', symbol: '‚ù§Ô∏è', color: '#ec407a' },
                { id: 'leaf', symbol: 'üçÉ', color: '#66bb6a' },
                { id: 'star', symbol: '‚≠ê', color: '#ffca28' },
                { id: 'moon', symbol: 'üåô', color: '#9575cd' }
            ];
            
            // Setup start button
            if (startButton) {
                startButton.onclick = function() {
                    initAudio(); // Initialize audio on user interaction
                    startGame();
                    return false;
                };
            }
            
            // Game setup function
            function startGame() {
                console.log("Game starting...");
                
                // Hide start overlay
                if (startOverlay) {
                    startOverlay.style.display = "none";
                }
                
                // Initialize game grid
                initializeGrid();
                
                // Setup path drawing events
                setupPathEvents();
            }
            
            // Initialize game grid
            function initializeGrid() {
                // Clear grid and game state
                gridContainer.innerHTML = '';
                gameState.grid = [];
                gameState.gemElements = [];
                
                // Create grid data structure
                for (let row = 0; row < GRID_ROWS; row++) {
                    gameState.grid[row] = [];
                    gameState.gemElements[row] = [];
                    
                    for (let col = 0; col < GRID_COLS; col++) {
                        // Create a random gem
                        const randomIndex = Math.floor(Math.random() * GEM_TYPES.length);
                        const gemType = GEM_TYPES[randomIndex];
                        gameState.grid[row][col] = { ...gemType };
                        
                        // Create DOM element for the gem
                        const gemElement = document.createElement('div');
                        gemElement.className = `gem ${gemType.id}`;
                        gemElement.textContent = gemType.symbol;
                        gemElement.dataset.row = row;
                        gemElement.dataset.col = col;
                        
                        // Add to grid and store reference
                        gridContainer.appendChild(gemElement);
                        gameState.gemElements[row][col] = gemElement;
                    }
                }
                
                // Check for any initial matches
                const initialMatches = checkMatches();
                if (initialMatches.length > 0) {
                    resolveMatches(initialMatches);
                }
            }
            
            // Setup touch and mouse events for path drawing
            function setupPathEvents() {
                let isDragging = false;
                
                // Touch events
                gridContainer.addEventListener('touchstart', handlePathStart, { passive: false });
                gridContainer.addEventListener('touchmove', handlePathMove, { passive: false });
                gridContainer.addEventListener('touchend', handlePathEnd);
                
                // Mouse events (for testing on desktop)
                gridContainer.addEventListener('mousedown', handlePathStart);
                gridContainer.addEventListener('mousemove', handlePathMove);
                gridContainer.addEventListener('mouseup', handlePathEnd);
                gridContainer.addEventListener('mouseleave', handlePathEnd);
                
                function handlePathStart(e) {
                    e.preventDefault();
                    
                    // Get the touched element
                    const element = getTouchedElement(e);
                    if (!element || !element.classList.contains('gem')) return;
                    
                    // Start path mode
                    gameState.pathMode = true;
                    isDragging = true;
                    
                    // Get gem coordinates
                    const row = parseInt(element.dataset.row);
                    const col = parseInt(element.dataset.col);
                    
                    // Start the path
                    startPath(row, col);
                }
                
                function handlePathMove(e) {
                    e.preventDefault();
                    
                    if (!isDragging || !gameState.pathMode) return;
                    
                    // Get the touched element
                    const element = getTouchedElement(e);
                    if (!element || !element.classList.contains('gem')) return;
                    
                    // Get gem coordinates
                    const row = parseInt(element.dataset.row);
                    const col = parseInt(element.dataset.col);
                    
                    // Try to add to path
                    addToPath(row, col);
                }
                
                function handlePathEnd(e) {
                    if (isDragging && gameState.pathMode) {
                        e.preventDefault();
                        finishPath();
                    }
                    isDragging = false;
                }
                
                function getTouchedElement(e) {
                    // Get touch or mouse position
                    let clientX, clientY;
                    
                    if (e.type.startsWith('touch')) {
                        if (e.touches.length === 0) return null;
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }
                    
                    // Get element at that position
                    return document.elementFromPoint(clientX, clientY);
                }
            }
            
            // Start a new path from a gem
            function startPath(row, col) {
                // Reset current path
                gameState.currentPath = [];
                clearPathVisuals();
                
                // Add the first gem to the path
                gameState.currentPath.push({ row, col });
                
                // Mark the gem as active
                const gemElement = gameState.gemElements[row][col];
                gemElement.classList.add('active');
                
                // Play select sound
                sounds.select();
                
                // Start the timer
                startPathTimer();
                
                // Add visual indicators
                addPathVisual(row, col);
            }
            
            // Add a gem to the current path
            function addToPath(row, col) {
                // If the path is empty, return
                if (gameState.currentPath.length === 0) return;
                
                // Get the last gem in the path
                const lastGem = gameState.currentPath[gameState.currentPath.length - 1];
                
                // Check if the new gem is adjacent to the last one
                if (!areGemsAdjacent(lastGem.row, lastGem.col, row, col)) return;
                
                // Check if the gem is already in the path
                const gemIndex = gameState.currentPath.findIndex(gem => gem.row === row && gem.col === col);
                
                if (gemIndex !== -1) {
                    // Allow backtracking to any previous position in the path
                    // First, store all gems that will be removed from the path
                    const removedGems = gameState.currentPath.slice(gemIndex + 1);
                    
                    // Truncate the path back to the position we're returning to (plus one)
                    gameState.currentPath = gameState.currentPath.slice(0, gemIndex + 1);
                    
                    // Remove the active class from all removed gems
                    removedGems.forEach(gem => {
                        const gemElement = gameState.gemElements[gem.row][gem.col];
                        gemElement.classList.remove('active');
                    });
                    
                    // Remove the corresponding path lines and dots
                    // We need to remove the lines and dots starting from the backtrack point
                    const lines = document.querySelectorAll('.path-line');
                    const dots = document.querySelectorAll('.path-dot');
                    
                    // Remove lines from gemIndex position onwards
                    for (let i = lines.length - 1; i >= gemIndex; i--) {
                        lines[i].remove();
                    }
                    
                    // Remove dots from gemIndex+1 position onwards (keep dot at backtrack position)
                    for (let i = dots.length - 1; i > gemIndex; i--) {
                        dots[i].remove();
                    }
                    
                    // Play swap sound for backtracking
                    sounds.swap();
                    return;
                }
                
                // Add the gem to the path
                gameState.currentPath.push({ row, col });
                
                // Mark the gem as active
                const gemElement = gameState.gemElements[row][col];
                gemElement.classList.add('active');
                
                // Simple swap of gems (current implementation)
                swapGems(lastGem.row, lastGem.col, row, col);
                
                // Draw line connecting to the previous gem
                drawPathLine(lastGem.row, lastGem.col, row, col);
                
                // Add dot at the new position
                addPathDot(row, col);
                
                // Play swap sound
                sounds.swap();
            }
            
            // Swap two adjacent gems (visually and in game state)
            function swapGems(row1, col1, row2, col2) {
                // Get the gems
                const gem1 = gameState.grid[row1][col1];
                const gem2 = gameState.grid[row2][col2];
                
                // Swap in game state
                gameState.grid[row1][col1] = gem2;
                gameState.grid[row2][col2] = gem1;
                
                // Update visuals
                const element1 = gameState.gemElements[row1][col1];
                const element2 = gameState.gemElements[row2][col2];
                
                // Update visuals
                element1.className = `gem ${gem2.id}`;
                element1.textContent = gem2.symbol;
                if (gameState.currentPath.some(p => p.row === row1 && p.col === col1)) {
                    element1.classList.add('active');
                }
                
                element2.className = `gem ${gem1.id}`;
                element2.textContent = gem1.symbol;
                if (gameState.currentPath.some(p => p.row === row2 && p.col === col2)) {
                    element2.classList.add('active');
                }
            }
            
            // Draw a line between two gems in the path
            function drawPathLine(row1, col1, row2, col2) {
                const gem1 = gameState.gemElements[row1][col1];
                const gem2 = gameState.gemElements[row2][col2];
                
                const rect1 = gem1.getBoundingClientRect();
                const rect2 = gem2.getBoundingClientRect();
                const gridRect = gridContainer.getBoundingClientRect();
                
                const x1 = rect1.left + rect1.width/2 - gridRect.left;
                const y1 = rect1.top + rect1.height/2 - gridRect.top;
                const x2 = rect2.left + rect2.width/2 - gridRect.left;
                const y2 = rect2.top + rect2.height/2 - gridRect.top;
                
                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1);
                
                const line = document.createElement('div');
                line.className = 'path-line';
                line.style.width = length + 'px';
                line.style.height = '4px';
                line.style.left = x1 + 'px';
                line.style.top = (y1 - 2) + 'px';
                line.style.transformOrigin = '0 50%';
                line.style.transform = `rotate(${angle}rad)`;
                
                gridContainer.appendChild(line);
            }
            
            // Add a dot at the gem position
            function addPathDot(row, col) {
                const gemElement = gameState.gemElements[row][col];
                const rect = gemElement.getBoundingClientRect();
                const gridRect = gridContainer.getBoundingClientRect();
                
                const dot = document.createElement('div');
                dot.className = 'path-dot';
                dot.style.left = (rect.left + rect.width/2 - gridRect.left - 6) + 'px';
                dot.style.top = (rect.top + rect.height/2 - gridRect.top - 6) + 'px';
                
                gridContainer.appendChild(dot);
            }
            
            // Add visual indicators for the path
            function addPathVisual(row, col) {
                // Add a highlight to the gem
                const gemElement = gameState.gemElements[row][col];
                gemElement.classList.add('active');
                
                // If this is not the first gem in the path, add a line
                if (gameState.currentPath.length > 1) {
                    const prevGem = gameState.currentPath[gameState.currentPath.length - 2];
                    drawPathLine(prevGem.row, prevGem.col, row, col);
                }
                
                // Add a dot at this position
                addPathDot(row, col);
            }
            
            // Clear all path visuals
            function clearPathVisuals() {
                // Remove active class from all gems
                document.querySelectorAll('.gem.active').forEach(gem => {
                    gem.classList.remove('active');
                });
                
                // Remove path lines and dots
                document.querySelectorAll('.path-line, .path-dot').forEach(el => {
                    el.remove();
                });
            }
            
            // Start the path timer
            function startPathTimer() {
                // Display the timer container
                timerContainer.style.display = 'block';
                
                // Reset timer
                gameState.pathTimeLeft = PATH_MOVE_TIME;
                
                // Update timer display initially
                updateTimerDisplay();
                
                // Clear any existing timer
                if (gameState.pathTimer) {
                    clearInterval(gameState.pathTimer);
                }
                
                // Start new timer
                const startTime = Date.now();
                let lastSecond = PATH_MOVE_TIME;
                
                gameState.pathTimer = setInterval(() => {
                    const elapsedSeconds = (Date.now() - startTime) / 1000;
                    gameState.pathTimeLeft = Math.max(0, PATH_MOVE_TIME - elapsedSeconds);
                    
                    // Play tick sound for the last 3 seconds
                    const currentSecond = Math.ceil(gameState.pathTimeLeft);
                    if (currentSecond < lastSecond) {
                        lastSecond = currentSecond;
                        if (currentSecond <= 3 && currentSecond > 0) {
                            sounds.timer();
                        }
                    }
                    
                    updateTimerDisplay();
                    
                    if (gameState.pathTimeLeft <= 0) {
                        finishPath();
                    }
                }, 100);
            }
            
            // Update the timer display
            function updateTimerDisplay() {
                const percentage = (gameState.pathTimeLeft / PATH_MOVE_TIME) * 100;
                timerCircle.textContent = Math.ceil(gameState.pathTimeLeft);
                timerCircle.style.background = `conic-gradient(#ffb703 ${percentage}%, transparent ${percentage}%)`;
            }
            
            // Finish the current path
            function finishPath() {
                // Stop the timer
                if (gameState.pathTimer) {
                    clearInterval(gameState.pathTimer);
                    gameState.pathTimer = null;
                }
                
                // Hide timer
                timerContainer.style.display = 'none';
                
                // If path is too short, cancel
                if (gameState.currentPath.length <= 1) {
                    cancelPath();
                    return;
                }
                
                // Remove path visuals
                clearPathVisuals();
                
                // Update the UI
                updateGridUI();
                
                // Check for matches
                const matches = checkMatches();
                if (matches.length > 0) {
                    // Found matches - process them
                    setTimeout(() => {
                        // Play match sound
                        sounds.match();
                        
                        // If it's a combo, play combo sound too
                        if (matches.length > 1) {
                            sounds.combo();
                        }
                        
                        resolveMatches(matches);
                    }, 300);
                } else {
                    // No matches - enemy attacks
                    enemyAttack();
                }
                
                // End path mode
                gameState.pathMode = false;
            }
            
            // Cancel the current path
            function cancelPath() {
                // Clear path visuals
                clearPathVisuals();
                
                // Reset path
                gameState.currentPath = [];
                
                // Update the UI to restore original state
                updateGridUI();
                
                // End path mode
                gameState.pathMode = false;
            }
            
            // Check if two gems are adjacent
            function areGemsAdjacent(row1, col1, row2, col2) {
                return (
                    (Math.abs(row1 - row2) === 1 && col1 === col2) ||
                    (Math.abs(col1 - col2) === 1 && row1 === row2)
                );
            }
            
            // Update the entire grid UI based on game state
            function updateGridUI() {
                for (let row = 0; row < GRID_ROWS; row++) {
                    for (let col = 0; col < GRID_COLS; col++) {
                        const gemElement = gameState.gemElements[row][col];
                        const gem = gameState.grid[row][col];
                        
                        if (gem) {
                            // Update class to match gem type
                            gemElement.className = `gem ${gem.id}`;
                            
                            // Update text content (gem symbol)
                            gemElement.textContent = gem.symbol;
                        }
                    }
                }
            }
            
            // Check for matches in the grid
            function checkMatches() {
                const matches = [];
                
                // Check horizontal matches
                for (let row = 0; row < GRID_ROWS; row++) {
                    for (let col = 0; col < GRID_COLS - 2; col++) {
                        if (!gameState.grid[row][col]) continue;
                        
                        const currentType = gameState.grid[row][col].id;
                        if (
                            gameState.grid[row][col + 1] && 
                            gameState.grid[row][col + 2] &&
                            currentType === gameState.grid[row][col + 1].id &&
                            currentType === gameState.grid[row][col + 2].id
                        ) {
                            // Found a horizontal match of at least 3
                            const matchedGems = [];
                            let nextCol = col;
                            
                            // Extend match if more than 3 in a row
                            while (
                                nextCol < GRID_COLS && 
                                gameState.grid[row][nextCol] &&
                                gameState.grid[row][nextCol].id === currentType
                            ) {
                                matchedGems.push({ row, col: nextCol });
                                nextCol++;
                            }
                            
                            matches.push({
                                type: currentType,
                                gems: matchedGems,
                                direction: 'horizontal'
                            });
                            
                            // Skip the matched gems to avoid duplicate matches
                            col = nextCol - 1;
                        }
                    }
                }
                
                // Check vertical matches
                for (let col = 0; col < GRID_COLS; col++) {
                    for (let row = 0; row < GRID_ROWS - 2; row++) {
                        if (!gameState.grid[row][col]) continue;
                        
                        const currentType = gameState.grid[row][col].id;
                        if (
                            gameState.grid[row + 1] && gameState.grid[row + 1][col] &&
                            gameState.grid[row + 2] && gameState.grid[row + 2][col] &&
                            currentType === gameState.grid[row + 1][col].id &&
                            currentType === gameState.grid[row + 2][col].id
                        ) {
                            // Found a vertical match of at least 3
                            const matchedGems = [];
                            let nextRow = row;
                            
                            // Extend match if more than 3 in a row
                            while (
                                nextRow < GRID_ROWS && 
                                gameState.grid[nextRow] && gameState.grid[nextRow][col] &&
                                gameState.grid[nextRow][col].id === currentType
                            ) {
                                matchedGems.push({ row: nextRow, col });
                                nextRow++;
                            }
                            
                            matches.push({
                                type: currentType,
                                gems: matchedGems,
                                direction: 'vertical'
                            });
                            
                            // Skip the matched gems to avoid duplicate matches
                            row = nextRow - 1;
                        }
                    }
                }
                
                return matches;
            }
            
            // Highlight matches in UI
            function highlightMatches(matches) {
                matches.forEach(match => {
                    match.gems.forEach(gem => {
                        const gemElement = gameState.gemElements[gem.row][gem.col];
                        gemElement.classList.add('matched');
                        
                        // Add sparkle effects
                        addSparkles(gemElement);
                    });
                });
            }
            
            // Add sparkle effects to matched gems
            function addSparkles(gemElement) {
                const rect = gemElement.getBoundingClientRect();
                const gridRect = gridContainer.getBoundingClientRect();
                
                // Create sparkles
                for (let i = 0; i < 5; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';
                    
                    // Random position within the gem
                    const left = rect.left - gridRect.left + Math.random() * rect.width;
                    const top = rect.top - gridRect.top + Math.random() * rect.height;
                    
                    sparkle.style.left = left + 'px';
                    sparkle.style.top = top + 'px';
                    sparkle.style.animation = `sparkle ${Math.random() * 0.5 + 0.5}s infinite alternate`;
                    
                    gridContainer.appendChild(sparkle);
                    
                    // Remove sparkle after the match animation
                    setTimeout(() => {
                        sparkle.remove();
                    }, 800);
                }
            }
            
            // Resolve matches and apply effects
            function resolveMatches(matches) {
                // Highlight matches
                highlightMatches(matches);
                
                // Show combo message if multiple matches
                if (matches.length > 1) {
                    comboText.textContent = `COMBO x${matches.length}!`;
                    comboText.style.animation = 'combo-popup 1.5s forwards';
                    setTimeout(() => {
                        comboText.style.animation = '';
                    }, 1500);
                }
                
                // Wait before processing
                setTimeout(() => {
                    // Apply effects based on matches
                    matches.forEach(match => {
                        // Apply effects based on gem type
                        applyGemEffect(match.type, match.gems.length);
                        
                        // Mark matched gems for removal
                        match.gems.forEach(gem => {
                            // Mark as null in game state (removed)
                            gameState.grid[gem.row][gem.col] = null;
                            
                            // Animate gem disappearing
                            const gemElement = gameState.gemElements[gem.row][gem.col];
                            gemElement.style.animation = 'disappear 0.3s forwards';
                        });
                    });
                    
                    // Wait for disappear animation
                    setTimeout(() => {
                        // Cascade gems down to fill gaps (P&D style)
                        cascadeGems();
                    }, 300);
                }, 800);
            }
            
            // Cascade gems down to fill gaps and add new gems
            function cascadeGems() {
                // First, calculate how far each gem needs to fall
                const fallDistances = [];
                for (let row = 0; row < GRID_ROWS; row++) {
                    fallDistances[row] = [];
                    for (let col = 0; col < GRID_COLS; col++) {
                        fallDistances[row][col] = 0;
                    }
                }
                
                // Calculate fall distances for each column
                for (let col = 0; col < GRID_COLS; col++) {
                    let emptySpaces = 0;
                    
                    // Scan from bottom to top
                    for (let row = GRID_ROWS - 1; row >= 0; row--) {
                        if (gameState.grid[row][col] === null) {
                            emptySpaces++;
                        } else if (emptySpaces > 0) {
                            fallDistances[row][col] = emptySpaces;
                        }
                    }
                }
                
                // Apply falling animations to existing gems
                for (let row = 0; row < GRID_ROWS; row++) {
                    for (let col = 0; col < GRID_COLS; col++) {
                        if (fallDistances[row][col] > 0 && gameState.grid[row][col] !== null) {
                            const gemElement = gameState.gemElements[row][col];
                            const newRow = row + fallDistances[row][col];
                            
                            // Calculate distance to fall
                            const gemRect = gemElement.getBoundingClientRect();
                            const fallPixels = fallDistances[row][col] * (gemRect.height + 2); // +2 for gap
                            
                            // Apply falling animation
                            gemElement.style.transform = `translateY(${fallPixels}px)`;
                            gemElement.style.transition = 'transform 0.5s ease-in-out';
                        }
                    }
                }
                
                // Play falling sound
                sounds.drop();
                
                // Apply the model changes after a delay
                setTimeout(() => {
                    // Update the game state with cascaded gems
                    // Move existing gems down
                    for (let col = 0; col < GRID_COLS; col++) {
                        // Process from bottom to top to avoid overwriting
                        const newColState = Array(GRID_ROWS).fill(null);
                        
                        // First move existing gems down
                        for (let row = 0; row < GRID_ROWS; row++) {
                            if (gameState.grid[row][col] !== null) {
                                const newRow = row + fallDistances[row][col];
                                newColState[newRow] = gameState.grid[row][col];
                            }
                        }
                        
                        // Now add new gems at the top
                        for (let row = 0; row < GRID_ROWS; row++) {
                            if (newColState[row] === null) {
                                // Create a new random gem
                                const randomIndex = Math.floor(Math.random() * GEM_TYPES.length);
                                newColState[row] = { ...GEM_TYPES[randomIndex] };
                            }
                        }
                        
                        // Update this column in the game state
                        for (let row = 0; row < GRID_ROWS; row++) {
                            gameState.grid[row][col] = newColState[row];
                        }
                    }
                    
                    // Update the UI
                    for (let row = 0; row < GRID_ROWS; row++) {
                        for (let col = 0; col < GRID_COLS; col++) {
                            const gemElement = gameState.gemElements[row][col];
                            const gem = gameState.grid[row][col];
                            
                            // Reset any animations and transitions
                            gemElement.style.animation = '';
                            gemElement.style.transition = '';
                            gemElement.style.transform = '';
                            gemElement.classList.remove('matched', 'active');
                            
                            // Update the element to match the new gem
                            if (gem) {
                                gemElement.className = `gem ${gem.id}`;
                                gemElement.textContent = gem.symbol;
                                
                                // Add appear animation for new gems at the top
                                if (fallDistances[0][col] > 0 && row < fallDistances[0][col]) {
                                    gemElement.style.animation = 'appear 0.3s forwards';
                                }
                            }
                        }
                    }
                    
                    // Check for any new matches after cascade
                    setTimeout(() => {
                        const newMatches = checkMatches();
                        if (newMatches.length > 0) {
                            // Found more matches - process them (combo)
                            resolveMatches(newMatches);
                        } else {
                            // No more matches - enemy attacks
                            enemyAttack();
                        }
                    }, 500);
                }, 500);
            }
            
            // Apply effects based on gem type and match size
            function applyGemEffect(gemType, matchSize) {
                const power = matchSize * 5; // Base power multiplied by match size
                
                switch(gemType) {
                    case 'heart':
                        // Heal the player
                        gameState.health = Math.min(gameState.health + power * 10, gameState.maxHealth);
                        break;
                    case 'fire':
                        // Deal damage to enemies
                        if (gameState.enemies.length > 0) {
                            gameState.enemies[0].health -= power * 15;
                            // Check if enemy is defeated
                            checkEnemyHealth();
                        }
                        break;
                    case 'water':
                        // Deal magic damage to enemies
                        if (gameState.enemies.length > 0) {
                            gameState.enemies[0].health -= power * 12;
                            // Check if enemy is defeated
                            checkEnemyHealth();
                        }
                        break;
                    case 'star':
                        // Bonus points and small healing
                        gameState.score += power * 20;
                        gameState.health = Math.min(gameState.health + power * 5, gameState.maxHealth);
                        break;
                    case 'moon':
                        // Weaken enemy attack
                        if (gameState.enemies.length > 0) {
                            gameState.enemies[0].attack = Math.max(1, gameState.enemies[0].attack - 1);
                        }
                        break;
                    case 'leaf':
                        // Buff heroes attack
                        gameState.heroes.forEach(hero => {
                            hero.attack += 1;
                        });
                        break;
                }
                
                // Update UI
                updateUI();
                
                // Show floating text for the effect
                showFloatingText(gemType, power);
            }
            
            // Check if enemy is defeated
            function checkEnemyHealth() {
                if (gameState.enemies.length > 0 && gameState.enemies[0].health <= 0) {
                    // Enemy defeated
                    gameState.enemies = [];
                    
                    // Spawn new enemy
                    setTimeout(() => {
                        spawnEnemy();
                    }, 1000);
                }
            }
            
            // Spawn a new enemy
            function spawnEnemy() {
                // Calculate enemy stats based on score
                const level = Math.floor(gameState.score / 500) + 1;
                const health = 80 + (level * 20);
                const attack = 5 + Math.floor(level / 2);
                
                // Create new enemy
                gameState.enemies = [{
                    name: `Enemy Lvl ${level}`,
                    health: health,
                    maxHealth: health,
                    attack: attack
                }];
                
                // Show level up message
                showFloatingText('level', level);
            }
            
            // Enemy attack
            function enemyAttack() {
                if (gameState.enemies.length === 0) return;
                
                setTimeout(() => {
                    const enemy = gameState.enemies[0];
                    const damage = enemy.attack;
                    
                    // Apply damage to player
                    gameState.health = Math.max(0, gameState.health - damage);
                    
                    // Show damage
                    showFloatingText('damage', damage);
                    
                    // Flash the enemy to show attack
                    const enemyElement = document.querySelector('.enemy');
                    if (enemyElement) {
                        enemyElement.style.animation = 'shake 0.5s';
                        setTimeout(() => {
                            enemyElement.style.animation = '';
                        }, 500);
                    }
                    
                    // Check if player is defeated
                    if (gameState.health <= 0) {
                        gameOver();
                        return;
                    }
                    
                    // Update UI
                    updateUI();
                }, 300);
            }
            
            // Game over
            function gameOver() {
                alert(`Game Over! Your score: ${gameState.score}`);
                startGame();
            }
            
            // Show floating text for gem effects
            function showFloatingText(gemType, power) {
                let text, color;
                
                switch(gemType) {
                    case 'heart':
                        text = `+${power * 10} HP`;
                        color = '#ec407a';
                        break;
                    case 'fire':
                        text = `${power * 15} DMG`;
                        color = '#ff7043';
                        break;
                    case 'water':
                        text = `${power * 12} MAGIC`;
                        color = '#42a5f5';
                        break;
                    case 'star':
                        text = `+${power * 20} PTS`;
                        color = '#ffca28';
                        break;
                    case 'moon':
                        text = 'WEAKEN';
                        color = '#9575cd';
                        break;
                    case 'leaf':
                        text = 'BUFF';
                        color = '#66bb6a';
                        break;
                    case 'damage':
                        text = `-${power} HP`;
                        color = '#f44336';
                        break;
                    case 'level':
                        text = `LEVEL ${power}!`;
                        color = '#ffd700';
                        break;
                    default:
                        text = `${power} EFFECT`;
                        color = 'white';
                }
                
                const floatingText = document.createElement('div');
                floatingText.textContent = text;
                floatingText.style.position = 'absolute';
                floatingText.style.color = color;
                floatingText.style.fontSize = '24px';
                floatingText.style.fontWeight = 'bold';
                floatingText.style.textShadow = '1px 1px 2px black';
                floatingText.style.top = '40px';
                floatingText.style.left = '50%';
                floatingText.style.transform = 'translateX(-50%)';
                floatingText.style.zIndex = '50';
                floatingText.style.pointerEvents = 'none';
                
                document.getElementById('dungeon-view').appendChild(floatingText);
                
                // Animate floating up and fading out
                let pos = 40;
                let opacity = 1;
                const interval = setInterval(() => {
                    pos -= 1;
                    opacity -= 0.02;
                    floatingText.style.top = pos + 'px';
                    floatingText.style.opacity = opacity;
                    
                    if (opacity <= 0) {
                        clearInterval(interval);
                        floatingText.remove();
                    }
                }, 20);
            }
            
            // Update UI elements based on game state
            function updateUI() {
                // Update health bar
                const healthPercentage = (gameState.health / gameState.maxHealth) * 100;
                healthFill.style.width = `${healthPercentage}%`;
                document.querySelector('#status-bar span:last-child').textContent = `${gameState.health}/${gameState.maxHealth}`;
                
                // Update hero stats
                const heroCards = document.querySelectorAll('.hero-card');
                gameState.heroes.forEach((hero, index) => {
                    if (index < heroCards.length) {
                        const statsElement = heroCards[index].querySelector('.hero-stats');
                        if (statsElement) {
                            statsElement.textContent = `${hero.attack} ‚öîÔ∏è`;
                        }
                    }
                });
            }
            
            // Add another way to start the game (for backup)
            document.addEventListener('click', function(e) {
                if (e.target.id === 'start-game-btn' || e.target.classList.contains('start-button')) {
                    initAudio(); // Initialize audio on user interaction
                    startGame();
                }
            });
        };
    </script>
</body>
</html>
