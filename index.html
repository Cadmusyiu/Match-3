<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Complete Puzzle RPG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background-color: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        
        #game-container {
            width: 100%;
            max-width: 430px;
            height: 100%;
            max-height: 760px;
            background-color: #222;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        #dungeon-view {
            height: 120px;
            background-color: #333;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .enemy {
            width: 60px;
            height: 60px;
            background-color: #e57373;
            border-radius: 10px;
            position: relative;
        }
        
        .enemy::before {
            content: "";
            position: absolute;
            top: 15px;
            left: 10px;
            width: 10px;
            height: 10px;
            background-color: white;
            border-radius: 50%;
            box-shadow: 30px 0 0 white;
        }
        
        .enemy::after {
            content: "";
            position: absolute;
            top: 35px;
            left: 20px;
            width: 20px;
            height: 5px;
            background-color: #333;
        }
        
        #heroes-area {
            display: flex;
            justify-content: space-around;
            padding: 5px;
            background-color: #333;
            height: 65px;
        }
        
        .hero-card {
            width: 50px;
            height: 55px;
            background-color: #555;
            border-radius: 5px;
            border: 2px solid #777;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .hero-icon {
            height: 35px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
        }
        
        .hero-stats {
            height: 20px;
            background-color: #444;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            color: white;
        }

        .skill-charge {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 14px;
            height: 14px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            font-size: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .skill-ready {
            animation: pulse-glow 1.5s infinite alternate;
        }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 5px #ffeb3b; }
            100% { box-shadow: 0 0 12px #ffeb3b; }
        }
        
        #status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background-color: #222;
            border-top: 2px solid #444;
            border-bottom: 2px solid #444;
            height: 30px;
        }
        
        #health-bar {
            height: 16px;
            background-color: #444;
            border-radius: 8px;
            overflow: hidden;
            flex-grow: 1;
            margin: 0 10px;
        }
        
        #health-fill {
            height: 100%;
            background-color: #f25;
            width: 100%;
        }

        #turn-counter {
            margin-left: 10px;
            font-size: 12px;
            background-color: #555;
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        #grid-container {
            flex-grow: 1;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 2px;
            padding: 2px;
            background-color: #111;
            position: relative;
        }
        
        .gem {
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            transition: transform 0.2s, background-color 0.2s;
        }
        
        .gem.active {
            transform: scale(1.1);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
            z-index: 10;
        }
        
        .gem.matched {
            animation: pulse 0.5s infinite alternate;
        }

        .gem.falling {
            animation: fall-in 0.5s forwards;
        }

        .gem.new {
            animation: appear 0.3s forwards;
        }

        @keyframes fall-in {
            0% { transform: translateY(-100%); }
            60% { transform: translateY(10%); }
            80% { transform: translateY(-5%); }
            100% { transform: translateY(0); }
        }

        @keyframes appear {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0.7; transform: scale(1.1); }
        }
        
        /* Path visuals */
        .path-line {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            z-index: 5;
        }
        
        .path-dot {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 6;
        }
        
        /* Timer display */
        #timer-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            z-index: 20;
            display: none;
        }
        
        #timer-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(#ffb703 0%, transparent 0%);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px black;
            animation: timer-pulse 1s infinite alternate;
        }
        
        @keyframes timer-pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }
        
        /* Combo text styles */
        #combo-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px #f00, 0 0 20px #ff0;
            opacity: 0;
            z-index: 30;
            pointer-events: none;
        }
        
        @keyframes combo-popup {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        
        /* Sparkle animation for matched gems */
        @keyframes sparkle {
            0% { transform: scale(1); opacity: 0.5; }
            100% { transform: scale(1.5); opacity: 1; }
        }
        
        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: white;
            box-shadow: 0 0 3px white, 0 0 5px white;
            pointer-events: none;
        }
        
        .water { background-color: #42a5f5; }
        .fire { background-color: #ff7043; }
        .heart { background-color: #ec407a; }
        .leaf { background-color: #66bb6a; }
        .star { background-color: #ffca28; }
        .moon { background-color: #9575cd; }
        
        /* Start overlay with game title and start button */
        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .start-title {
            font-size: 36px;
            margin-bottom: 30px;
            color: white;
            text-align: center;
        }
        
        .start-button {
            padding: 15px 40px;
            font-size: 24px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        .start-button:hover {
            background-color: #3e8e41;
        }

        /* Dungeon progress */
        #dungeon-progress {
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 14px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 3px 8px;
            border-radius: 10px;
        }

        /* Skills popup */
        #skills-popup {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #555;
            border-radius: 10px;
            padding: 10px;
            display: none;
            z-index: 50;
            width: 80%;
            max-width: 300px;
        }

        .skill-button {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            background-color: #444;
            border: 1px solid #666;
            border-radius: 5px;
            color: white;
            text-align: left;
            cursor: pointer;
        }

        .skill-button:hover {
            background-color: #555;
        }

        .skill-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Flash animation */
        @keyframes flash {
            0% { opacity: 0.3; }
            50% { opacity: 0.1; }
            100% { opacity: 0; }
        }

        /* Shake animation for enemy attack */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Dungeon view with enemy -->
        <div id="dungeon-view">
            <div class="enemy"></div>
            <div id="dungeon-progress">Floor 1-1</div>
        </div>
        
        <!-- Hero cards area -->
        <div id="heroes-area">
            <div class="hero-card" data-hero="0">
                <div class="hero-icon" style="background-color: #ab47bc;">‚öîÔ∏è</div>
                <div class="hero-stats">11 ‚öîÔ∏è</div>
                <div class="skill-charge">0</div>
            </div>
            <div class="hero-card" data-hero="1">
                <div class="hero-icon" style="background-color: #42a5f5;">üîÆ</div>
                <div class="hero-stats">16 ‚öîÔ∏è</div>
                <div class="skill-charge">0</div>
            </div>
            <div class="hero-card" data-hero="2">
                <div class="hero-icon" style="background-color: #66bb6a;">‚úì</div>
                <div class="hero-stats">8 ‚öîÔ∏è</div>
                <div class="skill-charge">0</div>
            </div>
        </div>
        
        <!-- Health bar -->
        <div id="status-bar">
            <span>HP:</span>
            <div id="health-bar">
                <div id="health-fill"></div>
            </div>
            <span>15700/15705</span>
            <div id="turn-counter">Turn: 3</div>
        </div>
        
        <!-- Game grid -->
        <div id="grid-container"></div>
        
        <!-- Timer display -->
        <div id="timer-container">
            <div id="timer-circle">5</div>
        </div>
        
        <!-- Combo text -->
        <div id="combo-text">COMBO!</div>
        
        <!-- Skills popup -->
        <div id="skills-popup">
            <div class="skill-button" data-hero="0">üí• Warrior Slash - 3x damage</div>
            <div class="skill-button disabled" data-hero="1">üí´ Mage Blast - Convert gems</div>
            <div class="skill-button disabled" data-hero="2">üíö Heal - Restore health</div>
        </div>
        
        <!-- Start overlay -->
        <div id="start-overlay">
            <h1 class="start-title">Puzzle RPG</h1>
            <button class="start-button" id="start-game-btn">START GAME</button>
        </div>
    </div>

    <script>
                    // Wait for page to fully load
        window.onload = function() {
            // Game constants
            const GRID_SIZE = 6;
            const PATH_MOVE_TIME = 5; // seconds
            const TURNS_UNTIL_ENEMY_ATTACK = 3;

            // Initialize AudioContext (must be initialized after user interaction)
            let audioContext;
            
            // Game state
            let gameState = {
                grid: [],
                heroes: [
                    { name: 'Warrior', health: 100, attack: 11, gemType: 'fire', skillCharge: 0, skillMax: 3, skillReady: false },
                    { name: 'Mage', health: 80, attack: 16, gemType: 'water', skillCharge: 0, skillMax: 4, skillReady: false },
                    { name: 'Healer', health: 70, attack: 8, gemType: 'heart', skillCharge: 0, skillMax: 3, skillReady: false }
                ],
                enemies: [
                    { name: 'Enemy', health: 100, maxHealth: 100, attack: 10 }
                ],
                health: 15700,
                maxHealth: 15705,
                score: 0,
                currentPath: [],
                pathMode: false,
                pathTimer: null,
                pathTimeLeft: PATH_MOVE_TIME,
                startingGem: null,
                startingGemPosition: null,
                gemElements: [],
                turnsUntilEnemyAttack: TURNS_UNTIL_ENEMY_ATTACK,
                dungeonFloor: 1,
                dungeonStage: 1
            };
            
            // Get DOM elements
            const startOverlay = document.getElementById('start-overlay');
            const startButton = document.getElementById('start-game-btn');
            const gridContainer = document.getElementById('grid-container');
            const healthFill = document.getElementById('health-fill');
            const timerContainer = document.getElementById('timer-container');
            const timerCircle = document.getElementById('timer-circle');
            const comboText = document.getElementById('combo-text');
            const skillsPopup = document.getElementById('skills-popup');
            const turnCounter = document.getElementById('turn-counter');
            const dungeonProgress = document.getElementById('dungeon-progress');
            
            // Gem types
            const GEM_TYPES = [
                { id: 'water', symbol: 'üíß', color: '#42a5f5' },
                { id: 'fire', symbol: 'üî•', color: '#ff7043' },
                { id: 'heart', symbol: '‚ù§Ô∏è', color: '#ec407a' },
                { id: 'leaf', symbol: 'üçÉ', color: '#66bb6a' },
                { id: 'star', symbol: '‚≠ê', color: '#ffca28' },
                { id: 'moon', symbol: 'üåô', color: '#9575cd' }
            ];
            
            // Initialize sound effects using Web Audio API
            const sounds = {
                select: {
                    play: function() {
                        if (audioContext) playSound(220, 0.05, 'sine', 0.2);
                    },
                    currentTime: 0
                },
                swap: {
                    play: function() {
                        if (audioContext) playSound(330, 0.05, 'sine', 0.2);
                    },
                    currentTime: 0
                },
                match: {
                    play: function() {
                        if (audioContext) {
                            playSound(440, 0.1, 'triangle', 0.3);
                            setTimeout(() => playSound(550, 0.1, 'triangle', 0.3), 100);
                        }
                    },
                    currentTime: 0
                },
                combo: {
                    play: function() {
                        if (audioContext) {
                            playSound(660, 0.1, 'triangle', 0.4);
                            setTimeout(() => playSound(880, 0.1, 'triangle', 0.4), 150);
                            setTimeout(() => playSound(1100, 0.2, 'triangle', 0.4), 300);
                        }
                    },
                    currentTime: 0
                },
                timer: {
                    play: function() {
                        if (audioContext) playSound(300, 0.05, 'sine', 0.2);
                    },
                    currentTime: 0
                },
                drop: {
                    play: function() {
                        if (audioContext) {
                            playSound(600, 0.05, 'sine', 0.1);
                            setTimeout(() => playSound(500, 0.05, 'sine', 0.1), 50);
                            setTimeout(() => playSound(400, 0.05, 'sine', 0.1), 100);
                        }
                    },
                    currentTime: 0
                },
                enemyAttack: {
                    play: function() {
                        if (audioContext) playSound(150, 0.3, 'sawtooth', 0.3);
                    },
                    currentTime: 0
                },
                skillActivate: {
                    play: function() {
                        if (audioContext) {
                            playSound(880, 0.1, 'square', 0.2);
                            setTimeout(() => playSound(1100, 0.2, 'square', 0.3), 100);
                        }
                    },
                    currentTime: 0
                }
            };
            
            // Function to play a sound with given parameters
            function playSound(frequency, duration, type = 'sine', volume = 0.5) {
                try {
                    if (!audioContext) return;
                    
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = type;
                    oscillator.frequency.value = frequency;
                    gainNode.gain.value = volume;
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    
                    // Fade out for smoother sound
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                    
                    // Stop the oscillator after duration
                    setTimeout(() => {
                        oscillator.stop();
                    }, duration * 1000);
                } catch (e) {
                    console.log("Failed to play sound:", e);
                }
            }
            
            // Setup start button
            if (startButton) {
                startButton.onclick = function() {
                    startGame();
                    return false;
                };
            }
            
            // Setup hero skill buttons
            document.querySelectorAll('.hero-card').forEach(card => {
                card.addEventListener('click', function() {
                    const heroIndex = this.dataset.hero;
                    if (gameState.heroes[heroIndex].skillReady) {
                        openSkillsPopup();
                    }
                });
            });
            
            // Setup skill buttons
            document.querySelectorAll('.skill-button').forEach(button => {
                button.addEventListener('click', function() {
                    const heroIndex = this.dataset.hero;
                    if (!this.classList.contains('disabled')) {
                        activateHeroSkill(heroIndex);
                        closeSkillsPopup();
                    }
                });
            });
            
            // Game setup function
            function startGame() {
                console.log("Game starting...");
                
                // Initialize audio context on first user interaction
                if (!audioContext) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    audioContext = new AudioContext();
                } else if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Hide start overlay
                if (startOverlay) {
                    startOverlay.style.display = "none";
                }
                
                // Initialize game state
                gameState.turnsUntilEnemyAttack = TURNS_UNTIL_ENEMY_ATTACK;
                gameState.dungeonFloor = 1;
                gameState.dungeonStage = 1;
                updateDungeonProgress();
                
                // Initialize game grid
                initializeGrid();
                
                // Setup path drawing events
                setupPathEvents();
                
                // Update UI
                updateUI();
            }
            
            // Update dungeon progress display
            function updateDungeonProgress() {
                dungeonProgress.textContent = `Floor ${gameState.dungeonFloor}-${gameState.dungeonStage}`;
            }
            
            // Open skills popup
            function openSkillsPopup() {
                skillsPopup.style.display = 'block';
                
                // Update skill button states
                document.querySelectorAll('.skill-button').forEach((button, index) => {
                    if (gameState.heroes[index].skillReady) {
                        button.classList.remove('disabled');
                    } else {
                        button.classList.add('disabled');
                    }
                });
            }
            
            // Close skills popup
            function closeSkillsPopup() {
                skillsPopup.style.display = 'none';
            }
            
            // Activate hero skill
            function activateHeroSkill(heroIndex) {
                const hero = gameState.heroes[heroIndex];
                if (!hero.skillReady) return;
                
                sounds.skillActivate.currentTime = 0;
                sounds.skillActivate.play();
                
                // Apply skill effect based on hero
                switch(heroIndex) {
                    case 0: // Warrior
                        if (gameState.enemies.length > 0) {
                            // Deal 3x damage
                            const damage = hero.attack * 3;
                            gameState.enemies[0].health -= damage;
                            showFloatingText('skill', `${damage} DMG!`);
                            
                            // Check if enemy is defeated
                            checkEnemyHealth();
                        }
                        break;
                    case 1: // Mage
                        // Convert random gems to water gems
                        const convertCount = Math.floor(Math.random() * 5) + 3; // Convert 3-7 gems
                        const waterGem = GEM_TYPES.find(gem => gem.id === 'water');
                        
                        let converted = 0;
                        while (converted < convertCount) {
                            const randomRow = Math.floor(Math.random() * GRID_SIZE);
                            const randomCol = Math.floor(Math.random() * GRID_SIZE);
                            
                            // Don't convert water gems
                            if (gameState.grid[randomRow][randomCol].id !== 'water') {
                                gameState.grid[randomRow][randomCol] = { ...waterGem };
                                
                                // Add sparkle animation
                                const gemElement = gameState.gemElements[randomRow][randomCol];
                                gemElement.className = `gem ${waterGem.id}`;
                                gemElement.textContent = waterGem.symbol;
                                
                                // Add conversion animation
                                gemElement.style.animation = 'pulse 0.3s 3';
                                setTimeout(() => {
                                    gemElement.style.animation = '';
                                }, 1000);
                                
                                converted++;
                            }
                        }
                        
                        showFloatingText('skill', `Converted ${convertCount} gems!`);
                        
                        // Check for matches after conversion
                        setTimeout(() => {
                            const matches = checkMatches();
                            if (matches.length > 0) {
                                resolveMatches(matches);
                            }
                        }, 1200);
                        break;
                    case 2: // Healer
                        // Heal 20% of max health
                        const healAmount = Math.floor(gameState.maxHealth * 0.2);
                        gameState.health = Math.min(gameState.health + healAmount, gameState.maxHealth);
                        
                        showFloatingText('skill', `+${healAmount} HP!`);
                        
                        updateUI();
                        break;
                }
                
                // Reset skill
                hero.skillReady = false;
                hero.skillCharge = 0;
                updateHeroSkillCharges();
            }
            
            // Initialize game grid
            function initializeGrid() {
                // Clear grid and game state
                gridContainer.innerHTML = '';
                gameState.grid = [];
                gameState.gemElements = [];
                
                // Create grid data structure
                for (let row = 0; row < GRID_SIZE; row++) {
                    gameState.grid[row] = [];
                    gameState.gemElements[row] = [];
                    
                    for (let col = 0; col < GRID_SIZE; col++) {
                        // Create a random gem
                        const randomIndex = Math.floor(Math.random() * GEM_TYPES.length);
                        const gemType = GEM_TYPES[randomIndex];
                        gameState.grid[row][col] = { ...gemType };
                        
                        // Create DOM element for the gem
                        const gemElement = document.createElement('div');
                        gemElement.className = `gem ${gemType.id}`;
                        gemElement.textContent = gemType.symbol;
                        gemElement.dataset.row = row;
                        gemElement.dataset.col = col;
                        
                        // Add to grid and store reference
                        gridContainer.appendChild(gemElement);
                        gameState.gemElements[row][col] = gemElement;
                    }
                }
                
                // Check for any initial matches
                const initialMatches = checkMatches();
                if (initialMatches.length > 0) {
                    resolveMatches(initialMatches);
                }
            }
            
            // Setup touch and mouse events for path drawing
            function setupPathEvents() {
                let isDragging = false;
                
                // Touch events
                gridContainer.addEventListener('touchstart', handlePathStart, { passive: false });
                gridContainer.addEventListener('touchmove', handlePathMove, { passive: false });
                gridContainer.addEventListener('touchend', handlePathEnd);
                
                // Mouse events (for testing on desktop)
                gridContainer.addEventListener('mousedown', handlePathStart);
                gridContainer.addEventListener('mousemove', handlePathMove);
                gridContainer.addEventListener('mouseup', handlePathEnd);
                gridContainer.addEventListener('mouseleave', handlePathEnd);
                
                function handlePathStart(e) {
                    e.preventDefault();
                    
                    // Get the touched element
                    const element = getTouchedElement(e);
                    if (!element || !element.classList.contains('gem')) return;
                    
                    // Start path mode
                    gameState.pathMode = true;
                    isDragging = true;
                    
                    // Get gem coordinates
                    const row = parseInt(element.dataset.row);
                    const col = parseInt(element.dataset.col);
                    
                    // Start the path
                    startPath(row, col);
                }
                
                function handlePathMove(e) {
                    e.preventDefault();
                    
                    if (!isDragging || !gameState.pathMode) return;
                    
                    // Get the touched element
                    const element = getTouchedElement(e);
                    if (!element || !element.classList.contains('gem')) return;
                    
                    // Get gem coordinates
                    const row = parseInt(element.dataset.row);
                    const col = parseInt(element.dataset.col);
                    
                    // Try to add to path
                    addToPath(row, col);
                }
                
                function handlePathEnd(e) {
                    if (isDragging && gameState.pathMode) {
                        e.preventDefault();
                        finishPath();
                    }
                    isDragging = false;
                }
                
                function getTouchedElement(e) {
                    // Get touch or mouse position
                    let clientX, clientY;
                    
                    if (e.type.startsWith('touch')) {
                        if (e.touches.length === 0) return null;
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }
                    
                    // Get element at that position
                    return document.elementFromPoint(clientX, clientY);
                }
            }
            
            // Start a new path from a gem
            function startPath(row, col) {
                // Reset current path
                gameState.currentPath = [];
                clearPathVisuals();
                
                // Add the first gem to the path
                gameState.currentPath.push({ row, col });
                
                // Store the starting gem for real-time visualization
                gameState.startingGem = { ...gameState.grid[row][col] };
                gameState.startingGemPosition = { row, col };
                
                // Mark the gem as active
                const gemElement = gameState.gemElements[row][col];
                gemElement.classList.add('active');
                
                // Play select sound (ensuring AudioContext is available)
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        sounds.select.currentTime = 0;
                        sounds.select.play();
                    });
                } else {
                    sounds.select.currentTime = 0;
                    sounds.select.play();
                }
                
                // Start the timer
                startPathTimer();
                
                // Add visual indicators
                addPathVisual(row, col);
            }
            
            // Add a gem to the current path
            function addToPath(row, col) {
                // If the path is empty, return
                if (gameState.currentPath.length === 0) return;
                
                // Get the last gem in the path
                const lastGem = gameState.currentPath[gameState.currentPath.length - 1];
                
                // Check if the new gem is adjacent to the last one
                if (!areGemsAdjacent(lastGem.row, lastGem.col, row, col)) return;
                
                // Check if attempting to go back to a previous position
                const gemIndex = gameState.currentPath.findIndex(gem => gem.row === row && gem.col === col);
                
                if (gemIndex !== -1) {
                    // If trying to go back to previous position
                    if (gemIndex === gameState.currentPath.length - 2) {
                        // Backtracking - pop the last position from the path
                        const removed = gameState.currentPath.pop();
                        const removedElement = gameState.gemElements[removed.row][removed.col];
                        removedElement.classList.remove('active');
                        
                        // Remove the last line and dot from visuals
                        const lines = document.querySelectorAll('.path-line');
                        if (lines.length > 0) {
                            lines[lines.length - 1].remove();
                        }
                        
                        const dots = document.querySelectorAll('.path-dot');
                        if (dots.length > 0) {
                            dots[dots.length - 1].remove();
                        }
                        
                        // Play swap sound
                        sounds.swap.currentTime = 0;
                        sounds.swap.play();
                        
                        // Update the preview of the grid
                        updateRealTimeGems();
                    }
                    return;
                }
                
                // Add the gem to the path
                gameState.currentPath.push({ row, col });
                
                // Mark the gem as active
                const gemElement = gameState.gemElements[row][col];
                gemElement.classList.add('active');
                
                // Draw line connecting to the previous gem
                drawPathLine(lastGem.row, lastGem.col, row, col);
                
                // Add dot at the new position
                addPathDot(row, col);
                
                // Update the preview of the grid
                updateRealTimeGems();
                
                // Play swap sound
                sounds.swap.currentTime = 0;
                sounds.swap.play();
            }
                
                // Add the gem to the path
                gameState.currentPath.push({ row, col });
                
                // Mark the gem as active
                const gemElement = gameState.gemElements[row][col];
                gemElement.classList.add('active');
                
                // Draw line connecting to the previous gem
                drawPathLine(lastGem.row, lastGem.col, row, col);
                
                // Add dot at the new position
                addPathDot(row, col);
                
                // Update real-time gem visualization
                updateRealTimeGems();
                
                // Play swap sound
                sounds.swap.currentTime = 0;
                sounds.swap.play();
            }
            
            // Draw a line between two gems in the path
            function drawPathLine(row1, col1, row2, col2) {
                const gem1 = gameState.gemElements[row1][col1];
                const gem2 = gameState.gemElements[row2][col2];
                
                const rect1 = gem1.getBoundingClientRect();
                const rect2 = gem2.getBoundingClientRect();
                const gridRect = gridContainer.getBoundingClientRect();
                
                const x1 = rect1.left + rect1.width/2 - gridRect.left;
                const y1 = rect1.top + rect1.height/2 - gridRect.top;
                const x2 = rect2.left + rect2.width/2 - gridRect.left;
                const y2 = rect2.top + rect2.height/2 - gridRect.top;
                
                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1);
                
                const line = document.createElement('div');
                line.className = 'path-line';
                line.style.width = length + 'px';
                line.style.height = '4px';
                line.style.left = x1 + 'px';
                line.style.top = (y1 - 2) + 'px';
                line.style.transformOrigin = '0 50%';
                line.style.transform = `rotate(${angle}rad)`;
                
                gridContainer.appendChild(line);
            }
            
            // Add a dot at the gem position
            function addPathDot(row, col) {
                const gemElement = gameState.gemElements[row][col];
                const rect = gemElement.getBoundingClientRect();
                const gridRect = gridContainer.getBoundingClientRect();
                
                const dot = document.createElement('div');
                dot.className = 'path-dot';
                dot.style.left = (rect.left + rect.width/2 - gridRect.left - 6) + 'px';
                dot.style.top = (rect.top + rect.height/2 - gridRect.top - 6) + 'px';
                
                gridContainer.appendChild(dot);
            }
            
            // Add visual indicators for the path
            function addPathVisual(row, col) {
                // Add a highlight to the gem
                const gemElement = gameState.gemElements[row][col];
                gemElement.classList.add('active');
                
                // If this is not the first gem in the path, add a line
                if (gameState.currentPath.length > 1) {
                    const prevGem = gameState.currentPath[gameState.currentPath.length - 2];
                    drawPathLine(prevGem.row, prevGem.col, row, col);
                }
                
                // Add a dot at this position
                addPathDot(row, col);
            }
            
            // Clear all path visuals
            function clearPathVisuals() {
                // Remove active class from all gems
                document.querySelectorAll('.gem.active').forEach(gem => {
                    gem.classList.remove('active');
                });
                
                // Remove path lines and dots
                document.querySelectorAll('.path-line, .path-dot').forEach(el => {
                    el.remove();
                });
            }
            
            // Start the path timer
            function startPathTimer() {
                // Display the timer container
                timerContainer.style.display = 'block';
                
                // Reset timer
                gameState.pathTimeLeft = PATH_MOVE_TIME;
                
                // Update timer display initially
                updateTimerDisplay();
                
                // Clear any existing timer
                if (gameState.pathTimer) {
                    clearInterval(gameState.pathTimer);
                }
                
                // Start new timer
                const startTime = Date.now();
                let lastSecond = PATH_MOVE_TIME;
                
                gameState.pathTimer = setInterval(() => {
                    const elapsedSeconds = (Date.now() - startTime) / 1000;
                    gameState.pathTimeLeft = Math.max(0, PATH_MOVE_TIME - elapsedSeconds);
                    
                    // Play tick sound for the last 3 seconds
                    const currentSecond = Math.ceil(gameState.pathTimeLeft);
                    if (currentSecond < lastSecond) {
                        lastSecond = currentSecond;
                        if (currentSecond <= 3 && currentSecond > 0) {
                            sounds.timer.currentTime = 0;
                            sounds.timer.play();
                        }
                    }
                    
                    updateTimerDisplay();
                    
                    if (gameState.pathTimeLeft <= 0) {
                        finishPath();
                    }
                }, 100);
            }
            
            // Update the timer display
            function updateTimerDisplay() {
                const percentage = (gameState.pathTimeLeft / PATH_MOVE_TIME) * 100;
                timerCircle.textContent = Math.ceil(gameState.pathTimeLeft);
                timerCircle.style.background = `conic-gradient(#ffb703 ${percentage}%, transparent ${percentage}%)`;
            }
            
            // Update gem positions in real-time as user drags
            function updateRealTimeGems() {
                // If path is too short, nothing to do
                if (gameState.currentPath.length <= 1) return;
                
                // Create a temporary copy of the original grid
                const tempGrid = [];
                for (let row = 0; row < GRID_SIZE; row++) {
                    tempGrid[row] = [];
                    for (let col = 0; col < GRID_SIZE; col++) {
                        tempGrid[row][col] = { ...gameState.grid[row][col] };
                    }
                }
                
                // Simulate all the swaps along the path
                for (let i = 0; i < gameState.currentPath.length - 1; i++) {
                    const current = gameState.currentPath[i];
                    const next = gameState.currentPath[i + 1];
                    
                    // Swap gems at these two positions
                    const temp = tempGrid[current.row][current.col];
                    tempGrid[current.row][current.col] = tempGrid[next.row][next.col];
                    tempGrid[next.row][next.col] = temp;
                }
                
                // Update the UI based on the temporary grid
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const gemElement = gameState.gemElements[row][col];
                        const gem = tempGrid[row][col];
                        
                        if (gem) {
                            // Update class to match gem type
                            gemElement.className = `gem ${gem.id}`;
                            if (gameState.currentPath.some(p => p.row === row && p.col === col)) {
                                gemElement.classList.add('active');
                            }
                            
                            // Update text content (gem symbol)
                            gemElement.textContent = gem.symbol;
                        }
                    }
                }
            }
            
            // Finish the current path
            function finishPath() {
                // Stop the timer
                if (gameState.pathTimer) {
                    clearInterval(gameState.pathTimer);
                    gameState.pathTimer = null;
                }
                
                // Hide timer
                timerContainer.style.display = 'none';
                
                // If path is too short, cancel
                if (gameState.currentPath.length <= 1) {
                    cancelPath();
                    return;
                }
                
                // Create a temporary copy of the grid
                const tempGrid = [];
                for (let row = 0; row < GRID_SIZE; row++) {
                    tempGrid[row] = [];
                    for (let col = 0; col < GRID_SIZE; col++) {
                        // Start with the original game state
                        tempGrid[row][col] = { ...gameState.grid[row][col] };
                    }
                }
                
                // For each adjacent pair in the path, swap the gems
                for (let i = 0; i < gameState.currentPath.length - 1; i++) {
                    const posA = gameState.currentPath[i];
                    const posB = gameState.currentPath[i + 1];
                    
                    // Simple swap between adjacent positions
                    const gemA = tempGrid[posA.row][posA.col];
                    const gemB = tempGrid[posB.row][posB.col];
                    
                    tempGrid[posA.row][posA.col] = gemB;
                    tempGrid[posB.row][posB.col] = gemA;
                }
                
                // Update the game grid
                gameState.grid = tempGrid;
                
                // Remove path visuals
                clearPathVisuals();
                
                // Update the UI
                updateGridUI();
                
                // Check for matches
                const matches = checkMatches();
                if (matches.length > 0) {
                    // Found matches - process them
                    setTimeout(() => {
                        // Play match sound
                        sounds.match.currentTime = 0;
                        sounds.match.play();
                        
                        // If it's a combo, play combo sound too
                        if (matches.length > 1) {
                            sounds.combo.currentTime = 0;
                            sounds.combo.play();
                        }
                        
                        resolveMatches(matches);
                    }, 300);
                } else {
                    // No matches - enemy's turn
                    processEnemyTurn();
                }
                
                // End path mode
                gameState.pathMode = false;
            }
            
            // Process enemy turn
            function processEnemyTurn() {
                // Decrement turns until enemy attack
                gameState.turnsUntilEnemyAttack--;
                
                // Update turn counter display
                turnCounter.textContent = `Turn: ${gameState.turnsUntilEnemyAttack}`;
                
                // Check if enemy should attack
                if (gameState.turnsUntilEnemyAttack <= 0) {
                    // Enemy attacks
                    enemyAttack();
                    
                    // Reset turn counter
                    gameState.turnsUntilEnemyAttack = TURNS_UNTIL_ENEMY_ATTACK;
                    turnCounter.textContent = `Turn: ${gameState.turnsUntilEnemyAttack}`;
                }
            }
            
            // Cancel the current path
            function cancelPath() {
                // Clear path visuals
                clearPathVisuals();
                
                // Reset path
                gameState.currentPath = [];
                
                // Update the UI to restore original state
                updateGridUI();
                
                // End path mode
                gameState.pathMode = false;
            }
            
            // Check if two gems are adjacent
            function areGemsAdjacent(row1, col1, row2, col2) {
                return (
                    (Math.abs(row1 - row2) === 1 && col1 === col2) ||
                    (Math.abs(col1 - col2) === 1 && row1 === row2)
                );
            }
            
            // Update the entire grid UI based on game state
            function updateGridUI() {
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const gemElement = gameState.gemElements[row][col];
                        const gem = gameState.grid[row][col];
                        
                        if (gem) {
                            // Update class to match gem type
                            gemElement.className = `gem ${gem.id}`;
                            
                            // Update text content (gem symbol)
                            gemElement.textContent = gem.symbol;
                        }
                    }
                }
            }
            
            // Check for matches in the grid
            function checkMatches() {
                const matches = [];
                
                // Check horizontal matches
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE - 2; col++) {
                        const currentType = gameState.grid[row][col].id;
                        if (
                            currentType === gameState.grid[row][col + 1].id &&
                            currentType === gameState.grid[row][col + 2].id
                        ) {
                            // Found a horizontal match of at least 3
                            const matchedGems = [];
                            let nextCol = col;
                            
                            // Extend match if more than 3 in a row
                            while (
                                nextCol < GRID_SIZE && 
                                gameState.grid[row][nextCol].id === currentType
                            ) {
                                matchedGems.push({ row, col: nextCol });
                                nextCol++;
                            }
                            
                            matches.push({
                                type: currentType,
                                gems: matchedGems,
                                direction: 'horizontal'
                            });
                            
                            // Skip the matched gems to avoid duplicate matches
                            col = nextCol - 1;
                        }
                    }
                }
                
                // Check vertical matches
                for (let col = 0; col < GRID_SIZE; col++) {
                    for (let row = 0; row < GRID_SIZE - 2; row++) {
                        const currentType = gameState.grid[row][col].id;
                        if (
                            currentType === gameState.grid[row + 1][col].id &&
                            currentType === gameState.grid[row + 2][col].id
                        ) {
                            // Found a vertical match of at least 3
                            const matchedGems = [];
                            let nextRow = row;
                            
                            // Extend match if more than 3 in a row
                            while (
                                nextRow < GRID_SIZE && 
                                gameState.grid[nextRow][col].id === currentType
                            ) {
                                matchedGems.push({ row: nextRow, col });
                                nextRow++;
                            }
                            
                            matches.push({
                                type: currentType,
                                gems: matchedGems,
                                direction: 'vertical'
                            });
                            
                            // Skip the matched gems to avoid duplicate matches
                            row = nextRow - 1;
                        }
                    }
                }
                
                return matches;
            }
            
            // Highlight matches in UI
            function highlightMatches(matches) {
                matches.forEach(match => {
                    match.gems.forEach(gem => {
                        const gemElement = gameState.gemElements[gem.row][gem.col];
                        gemElement.classList.add('matched');
                        
                        // Add sparkle effects
                        addSparkles(gemElement);
                    });
                });
            }
            
            // Add sparkle effects to matched gems
            function addSparkles(gemElement) {
                const rect = gemElement.getBoundingClientRect();
                const gridRect = gridContainer.getBoundingClientRect();
                
                // Create 5 sparkles per gem
                for (let i = 0; i < 5; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';
                    
                    // Random position within the gem
                    const left = rect.left - gridRect.left + Math.random() * rect.width;
                    const top = rect.top - gridRect.top + Math.random() * rect.height;
                    
                    sparkle.style.left = left + 'px';
                    sparkle.style.top = top + 'px';
                    sparkle.style.animation = `sparkle ${Math.random() * 0.5 + 0.5}s infinite alternate`;
                    sparkle.style.transformOrigin = 'center';
                    
                    gridContainer.appendChild(sparkle);
                    
                    // Remove sparkle after the match animation
                    setTimeout(() => {
                        sparkle.remove();
                    }, 800);
                }
            }
            
            // Resolve matches and apply effects
            function resolveMatches(matches) {
                // Highlight matches
                highlightMatches(matches);
                
                // Show combo message if multiple matches
                if (matches.length > 1) {
                    comboText.textContent = `COMBO x${matches.length}!`;
                    comboText.style.animation = 'combo-popup 1.5s forwards';
                    setTimeout(() => {
                        comboText.style.animation = '';
                    }, 1500);
                    
                    // Create flash effect for combo
                    const flash = document.createElement('div');
                    flash.style.position = 'absolute';
                    flash.style.top = '0';
                    flash.style.left = '0';
                    flash.style.width = '100%';
                    flash.style.height = '100%';
                    flash.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                    flash.style.zIndex = '30';
                    flash.style.pointerEvents = 'none';
                    flash.style.animation = 'flash 0.5s';
                    
                    gridContainer.appendChild(flash);
                    
                    setTimeout(() => {
                        flash.remove();
                    }, 500);
                }
                
                // Wait before processing
                setTimeout(() => {
                    // Apply effects based on matches
                    matches.forEach(match => {
                        // Apply effects based on gem type
                        applyGemEffect(match.type, match.gems.length);
                        
                        // Mark matched gems for removal in game state
                        match.gems.forEach(gem => {
                            gameState.grid[gem.row][gem.col] = null;
                        });
                    });
                    
                    // Update UI - visually remove the gems
                    for (let row = 0; row < GRID_SIZE; row++) {
                        for (let col = 0; col < GRID_SIZE; col++) {
                            const gemElement = gameState.gemElements[row][col];
                            
                            // If this gem was matched (is now null in the game state)
                            if (gameState.grid[row][col] === null) {
                                // Animate disappearance
                                gemElement.style.transform = 'scale(0)';
                                gemElement.style.opacity = '0';
                                gemElement.style.transition = 'transform 0.3s, opacity 0.3s';
                            }
                        }
                    }
                    
                    // Wait for disappear animation
                    setTimeout(() => {
                        // Remove any lingering matched classes
                        document.querySelectorAll('.gem.matched').forEach(gem => {
                            gem.classList.remove('matched');
                        });
                        
                        // Reset transitions for all gems
                        document.querySelectorAll('.gem').forEach(gem => {
                            gem.style.transition = '';
                        });
                        
                        // Drop gems to fill gaps with animation
                        dropGemsWithAnimation();
                    }, 300);
                }, 800);
            }
            
            // Apply effects based on gem type and match size
            function applyGemEffect(gemType, matchSize) {
                const power = matchSize * 5; // Base power multiplied by match size
                
                switch(gemType) {
                    case 'heart':
                        // Heal the player
                        gameState.health = Math.min(gameState.health + power * 10, gameState.maxHealth);
                        
                        // Charge Healer's skill
                        chargeHeroSkill(2);
                        break;
                    case 'fire':
                        // Deal damage to enemies
                        if (gameState.enemies.length > 0) {
                            gameState.enemies[0].health -= power * 15;
                            // Check if enemy is defeated
                            checkEnemyHealth();
                        }
                        
                        // Charge Warrior's skill
                        chargeHeroSkill(0);
                        break;
                    case 'water':
                        // Deal magic damage to enemies
                        if (gameState.enemies.length > 0) {
                            gameState.enemies[0].health -= power * 12;
                            // Check if enemy is defeated
                            checkEnemyHealth();
                        }
                        
                        // Charge Mage's skill
                        chargeHeroSkill(1);
                        break;
                    case 'star':
                        // Bonus points and small healing
                        gameState.score += power * 20;
                        gameState.health = Math.min(gameState.health + power * 5, gameState.maxHealth);
                        break;
                    case 'moon':
                        // Weaken enemy attack
                        if (gameState.enemies.length > 0) {
                            gameState.enemies[0].attack = Math.max(1, gameState.enemies[0].attack - 1);
                        }
                        break;
                    case 'leaf':
                        // Buff heroes attack
                        gameState.heroes.forEach(hero => {
                            hero.attack += 1;
                        });
                        break;
                }
                
                // Update UI
                updateUI();
                
                // Show floating text for the effect
                showFloatingText(gemType, power);
            }
            
            // Charge a hero's skill
            function chargeHeroSkill(heroIndex) {
                const hero = gameState.heroes[heroIndex];
                if (hero.skillReady) return; // Already charged
                
                hero.skillCharge++;
                
                // Check if skill is fully charged
                if (hero.skillCharge >= hero.skillMax) {
                    hero.skillReady = true;
                    hero.skillCharge = hero.skillMax;
                    
                    // Add visual indicator
                    const heroCard = document.querySelector(`.hero-card[data-hero="${heroIndex}"]`);
                    if (heroCard) {
                        const skillCharge = heroCard.querySelector('.skill-charge');
                        if (skillCharge) {
                            skillCharge.classList.add('skill-ready');
                        }
                    }
                }
                
                // Update skill charge display
                updateHeroSkillCharges();
            }
            
            // Update hero skill charge displays
            function updateHeroSkillCharges() {
                gameState.heroes.forEach((hero, index) => {
                    const heroCard = document.querySelector(`.hero-card[data-hero="${index}"]`);
                    if (heroCard) {
                        const skillCharge = heroCard.querySelector('.skill-charge');
                        if (skillCharge) {
                            skillCharge.textContent = hero.skillCharge;
                            
                            if (hero.skillReady) {
                                skillCharge.classList.add('skill-ready');
                            } else {
                                skillCharge.classList.remove('skill-ready');
                            }
                        }
                    }
                });
            }
            
            // Check if enemy is defeated
            function checkEnemyHealth() {
                if (gameState.enemies.length > 0 && gameState.enemies[0].health <= 0) {
                    // Enemy defeated
                    gameState.enemies = [];
                    
                    // Progress to next stage
                    advanceDungeon();
                    
                    // Spawn new enemy
                    setTimeout(() => {
                        spawnEnemy();
                    }, 1000);
                }
            }
            
            // Advance to next dungeon stage
            function advanceDungeon() {
                gameState.dungeonStage++;
                
                // Check if we've completed a floor (every 5 stages)
                if (gameState.dungeonStage > 5) {
                    gameState.dungeonFloor++;
                    gameState.dungeonStage = 1;
                }
                
                // Update dungeon progress display
                updateDungeonProgress();
            }
            
            // Spawn a new enemy
            function spawnEnemy() {
                // Calculate enemy stats based on dungeon progress
                const level = (gameState.dungeonFloor - 1) * 5 + gameState.dungeonStage;
                const health = 80 + (level * 20);
                const attack = 5 + Math.floor(level / 2);
                
                // Create new enemy
                gameState.enemies = [{
                    name: `Enemy Lvl ${level}`,
                    health: health,
                    maxHealth: health,
                    attack: attack
                }];
                
                // Show level up message
                showFloatingText('level', level);
            }
            
            // Enemy attack
            function enemyAttack() {
                if (gameState.enemies.length === 0) return;
                
                setTimeout(() => {
                    const enemy = gameState.enemies[0];
                    const damage = enemy.attack;
                    
                    // Apply damage to player
                    gameState.health = Math.max(0, gameState.health - damage);
                    
                    // Play enemy attack sound
                    sounds.enemyAttack.currentTime = 0;
                    sounds.enemyAttack.play();
                    
                    // Show damage
                    showFloatingText('damage', damage);
                    
                    // Flash the enemy to show attack
                    const enemyElement = document.querySelector('.enemy');
                    if (enemyElement) {
                        enemyElement.style.animation = 'shake 0.5s';
                        setTimeout(() => {
                            enemyElement.style.animation = '';
                        }, 500);
                    }
                    
                    // Check if player is defeated
                    if (gameState.health <= 0) {
                        gameOver();
                        return;
                    }
                    
                    // Update UI
                    updateUI();
                }, 300);
            }
            
            // Game over
            function gameOver() {
                alert(`Game Over! Your score: ${gameState.score}`);
                startGame();
            }
            
            // Show floating text for gem effects
            function showFloatingText(gemType, power) {
                let text, color;
                
                switch(gemType) {
                    case 'heart':
                        text = `+${power * 10} HP`;
                        color = '#ec407a';
                        break;
                    case 'fire':
                        text = `${power * 15} DMG`;
                        color = '#ff7043';
                        break;
                    case 'water':
                        text = `${power * 12} MAGIC`;
                        color = '#42a5f5';
                        break;
                    case 'star':
                        text = `+${power * 20} PTS`;
                        color = '#ffca28';
                        break;
                    case 'moon':
                        text = 'WEAKEN';
                        color = '#9575cd';
                        break;
                    case 'leaf':
                        text = 'BUFF';
                        color = '#66bb6a';
                        break;
                    case 'damage':
                        text = `-${power} HP`;
                        color = '#f44336';
                        break;
                    case 'level':
                        text = `LEVEL ${power}!`;
                        color = '#ffd700';
                        break;
                    case 'skill':
                        text = power;
                        color = '#ff5722';
                        break;
                    default:
                        text = `${power} EFFECT`;
                        color = 'white';
                }
                
                const floatingText = document.createElement('div');
                floatingText.textContent = text;
                floatingText.style.position = 'absolute';
                floatingText.style.color = color;
                floatingText.style.fontSize = '24px';
                floatingText.style.fontWeight = 'bold';
                floatingText.style.textShadow = '1px 1px 2px black';
                floatingText.style.top = '40px';
                floatingText.style.left = '50%';
                floatingText.style.transform = 'translateX(-50%)';
                floatingText.style.zIndex = '50';
                floatingText.style.pointerEvents = 'none';
                
                document.getElementById('dungeon-view').appendChild(floatingText);
                
                // Animate floating up and fading out
                let pos = 40;
                let opacity = 1;
                const interval = setInterval(() => {
                    pos -= 1;
                    opacity -= 0.02;
                    floatingText.style.top = pos + 'px';
                    floatingText.style.opacity = opacity;
                    
                    if (opacity <= 0) {
                        clearInterval(interval);
                        floatingText.remove();
                    }
                }, 20);
            }
            
            // Drop gems with animation to fill empty spaces
            function dropGemsWithAnimation() {
                // Create a map to track how far each gem needs to fall
                const fallDistances = [];
                for (let row = 0; row < GRID_SIZE; row++) {
                    fallDistances[row] = [];
                    for (let col = 0; col < GRID_SIZE; col++) {
                        fallDistances[row][col] = 0;
                    }
                }
                
                // Calculate fall distances
                for (let col = 0; col < GRID_SIZE; col++) {
                    let emptySpaces = 0;
                    
                    for (let row = GRID_SIZE - 1; row >= 0; row--) {
                        if (gameState.grid[row][col] === null) {
                            emptySpaces++;
                        } else if (emptySpaces > 0) {
                            fallDistances[row][col] = emptySpaces;
                        }
                    }
                }
                
                // First, add falling animation classes to gems that will move
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (fallDistances[row][col] > 0 && gameState.grid[row][col] !== null) {
                            const gemElement = gameState.gemElements[row][col];
                            gemElement.classList.add('falling');
                            
                            // Calculate the distance to fall in pixels
                            const gemHeight = gemElement.offsetHeight + 2; // +2 for gap
                            const fallDistance = fallDistances[row][col] * gemHeight;
                            
                            // Apply the falling animation
                            gemElement.style.transform = `translateY(${fallDistance}px)`;
                            gemElement.style.transition = 'transform 0.5s cubic-bezier(0.2, 0.8, 0.3, 1.2)';
                        }
                    }
                }
                
                // Play falling sound
                sounds.drop.currentTime = 0;
                sounds.drop.play();
                
                // Wait for animation to start
                setTimeout(() => {
                    // Apply the actual gem movement in the model data
                    for (let col = 0; col < GRID_SIZE; col++) {
                        // Count empty spaces from bottom to top
                        let emptySpaces = 0;
                        
                        for (let row = GRID_SIZE - 1; row >= 0; row--) {
                            if (gameState.grid[row][col] === null) {
                                emptySpaces++;
                            } else if (emptySpaces > 0) {
                                // Move gem down by the number of empty spaces
                                gameState.grid[row + emptySpaces][col] = gameState.grid[row][col];
                                gameState.grid[row][col] = null;
                            }
                        }
                        
                        // Fill top rows with new random gems
                        for (let row = 0; row < emptySpaces; row++) {
                            const randomIndex = Math.floor(Math.random() * GEM_TYPES.length);
                            gameState.grid[row][col] = { ...GEM_TYPES[randomIndex] };
                        }
                    }
                    
                    // Wait for falling animation to complete
                    setTimeout(() => {
                        // Reset all transitions and update UI to match model
                        document.querySelectorAll('.gem').forEach(gem => {
                            gem.style.transition = '';
                            gem.style.transform = '';
                            gem.classList.remove('falling', 'new', 'matched');
                        });
                        
                        // Update the UI to show the new grid state
                        updateGridUI();
                        
                        // Add appearance animation for new gems
                        for (let row = 0; row < GRID_SIZE; row++) {
                            for (let col = 0; col < GRID_SIZE; col++) {
                                // If this position was empty and now has a new gem
                                if (row < fallDistances.reduce((max, row) => Math.max(max, row[col]), 0)) {
                                    const gemElement = gameState.gemElements[row][col];
                                    gemElement.classList.add('new');
                                    
                                    // Remove animation class after animation completes
                                    setTimeout(() => {
                                        gemElement.classList.remove('new');
                                    }, 500);
                                }
                            }
                        }
                        
                        // Check for matches after dropping
                        setTimeout(() => {
                            const newMatches = checkMatches();
                            if (newMatches.length > 0) {
                                // Found more matches (skyfall)
                                resolveMatches(newMatches);
                            } else {
                                // No more matches - enemy's turn
                                processEnemyTurn();
                            }
                        }, 600);
                    }, 500); // Wait for fall animation
                }, 100); // Small delay before updating model
            }
            
            // Update grid UI with animations for new and falling gems
            function updateGridUIWithAnimations(fallDistances) {
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const gemElement = gameState.gemElements[row][col];
                        const gem = gameState.grid[row][col];
                        
                        if (gem) {
                            // Update class to match gem type
                            gemElement.className = `gem ${gem.id}`;
                            
                            // Add animations for new gems
                            if (row < GRID_SIZE && gameState.grid[row][col] !== null) {
                                // Check if this is a new gem from the top
                                if (row < fallDistances.reduce((max, row) => Math.max(max, row[col]), 0)) {
                                    gemElement.classList.add('new');
                                    
                                    // Remove animation class after animation completes
                                    setTimeout(() => {
                                        gemElement.classList.remove('new');
                                    }, 500);
                                }
                            }
                            
                            // Update text content (gem symbol)
                            gemElement.textContent = gem.symbol;
                        }
                    }
                }
                
                // Remove all animation classes after animations complete
                setTimeout(() => {
                    document.querySelectorAll('.gem').forEach(gem => {
                        gem.classList.remove('falling', 'new');
                    });
                }, 600);
            }
            
            // Update UI elements based on game state
            function updateUI() {
                // Update health bar
                const healthPercentage = (gameState.health / gameState.maxHealth) * 100;
                healthFill.style.width = `${healthPercentage}%`;
                document.querySelector('#status-bar span:last-child').textContent = `${gameState.health}/${gameState.maxHealth}`;
                
                // Update hero stats
                const heroCards = document.querySelectorAll('.hero-card');
                gameState.heroes.forEach((hero, index) => {
                    if (index < heroCards.length) {
                        const statsElement = heroCards[index].querySelector('.hero-stats');
                        if (statsElement) {
                            statsElement.textContent = `${hero.attack} ‚öîÔ∏è`;
                        }
                    }
                });
                
                // Update turn counter
                turnCounter.textContent = `Turn: ${gameState.turnsUntilEnemyAttack}`;
                
                // Update skill charges
                updateHeroSkillCharges();
            }
            
            // Add another way to start the game (for backup)
            document.addEventListener('click', function(e) {
                if (e.target.id === 'start-game-btn' || e.target.classList.contains('start-button')) {
                    startGame();
                }
            });
            
            // Close skills popup if clicking outside
            document.addEventListener('click', function(e) {
                if (skillsPopup.style.display === 'block' && !skillsPopup.contains(e.target) && !e.target.classList.contains('hero-card')) {
                    closeSkillsPopup();
                }
            });
        };
    </script>
</body>
</html>
